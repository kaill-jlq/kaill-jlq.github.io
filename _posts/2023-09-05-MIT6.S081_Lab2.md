---
title: MIT6.S081
layout: post
post-image: "https://image.baidu.com/search/down?tn=download&word=download&ie=utf8&fr=detail&url=https%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F0c9afc30856256436a2738bd1d05e68daa5bd3d2.jpg&thumburl=https%3A%2F%2Fimg0.baidu.com%2Fit%2Fu%3D2805645800%2C3904524944%26fm%3D253%26fmt%3Dauto%26app%3D120%26f%3DJPEG%3Fw%3D800%26h%3D500"
tags: OS
description: 这里是本人的第一篇博客，主要记录一下本人在课程MIT6.S081记录的部分笔记
---

## 前言
> 由于写此笔记的时候前三课并不在此记录(~~我懒得再写一遍~~)，故笔记从第四课开始

## Lecture 4
在上`lecture 4`前，我先阅读了`book-riscv-rev1`的第三章，有关`page table`

首先，**为什么需要页表**？

+ 页表的存在是为了实现强隔离性，防止一个程序影响另外的程序，或者影响操作系统，地址空间的概念使得程序之间能够彼此相互独立，如cat程序向地址1000写入数据，就不会影响到shell程序地址1000的位置。

**`SATP`寄存器：CPU中用于存放页表的物理地址的寄存器**，如果从一个程序切换到另一个程序，SATP中的地址也应相应的转换为另一个程序页表的物理地址（由内核完成写SATP寄存器的操作），对于多级页表，SATP寄存器会指向最高一级的`page directory`的物理内存地址



#### MMU:

+ `MMU`（`Memory Management Unit`，内存管理单元）是一种计算机硬件单元，它检查内存总线上的所有内存引用，将这些请求（称为虚拟内存地址）转换为主内存中的物理地址
+ MMU通过查找SATP寄存器，找到页表的位置，从而确定虚拟地址和物理地址的映射关系。

多级页表:

+ 一个多级页表，高层的页目录存放低层页目录的物理地址（44bit），然后用虚拟地址的某几位来索引低级页目录。
+ 值得注意的是。这里存放物理地址是44bit，而**剩余的低12bit全为0**，这样才组成了一个完整的物理地址，即下一级页目录的物理地址

优点：

+ **更加节省空间**，例如，如果应用程序仅使用从地址 0 开始的几个页，则顶层页目录的 1 到 511 项无效，并且内核不必为 511 中间页目录分配这些页。 此外，内核也不必为那些 511 个中间页目录的底层页目录分配页面。因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。

缺点：

+ 因为 CPU 在执行转换时会在硬件中遍历三级结构，所以**缺点**是 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将最近查找过的页表条目**缓存**在 `Translation Look-aside Buffer` (TLB) 中，即TLB会存放**最近的虚拟地址到物理地址的映射关系**。在切换`page table`时，TLB需要被清空，在RISC-V中，清空TLB的指令是`sfence_vma`



![Test Image2](/assets/images/page_table.png)

+ 每个PTE对应于一个`page`，用虚拟地址中index来查找，index查找到的地址是该页的**起始物理地址**，对应于4096个字节，而虚拟地址的offset则是查找对应于该page的哪部分字节，通常来说，一个page共有4096bytes，为 $2^{12}$ ，故需要12位的`offset`来索引位于那个字节
+ 如上图所示，在RISC-V中，虚拟地址的高 25位并未使用，只用了低39位，也就是说，虚拟地址的内存数量只有 $2^{39}$ 个，即512GB
+ RISC-V中，物理内存是56bit，也就是
+ 在RISC-V中，物理内存地址是56位，这意味着物理地址空间最大为2的56次方字节。然而，大多数主板还不支持这么大的物理内存，但原则上，如果能造出这样的主板，那么最多可以支持 $2^{56}$ 字节的物理内存。


![Test Image2](/assets/images/PTE.png)

如上图所示，每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。该图显示了它是如何工作的。标志和所有其他与页面硬件相关的结构在（**kernel/riscv.h**）中定义。



![Test Image](/assets/images/kernal_space.png)

+ 在进程地址空间中的`trampoline`和用户地址空间中的`trampoline`实际上是同一个东西。它们都指向内存中的同一个位置，用于在内核态和用户态之间进行切换。

+ 实际的物理地址空间中，低于0x80000000为不同的I/O设备，高于0x80000000会走向DRAM
+ `kernal text`存放代码，被标志为R-X，代码可读，可执行，但不可写，`kernal data`存放数据，可读写，但不可执行

#### 代码部分：

大多数用于操作地址空间和页表的xv6代码都写在 **vm.c** ([kernel/vm.c:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/vm.c#L1)) 中。最核心的函数是`walk`和`mappages`。

+ `mappages`函数的主要作用是在页表中创建新的虚拟地址到物理地址的映射。这意味着它将一个虚拟地址关联到一个物理地址，使得当程序试图访问这个虚拟地址时，硬件会自动将其转换为对应的物理地址。举个例子，假设我们有一个物理内存页，其物理地址是0x1000，我们想让一个进程能够通过虚拟地址0x2000来访问这个内存页。我们就可以使用`mappages`函数来创建这个映射。函数调用可能类似于`mappages(pagetable, 0x2000, PGSIZE, 0x1000, PTE_W | PTE_X | PTE_R)`。这样，当进程试图访问虚拟地址0x2000时，硬件会自动将其转换为物理地址0x1000，从而访问到正确的内存页。

+ 在查找PTE中的虚拟地址时，`walk`(**kernel/vm.c**:72)模仿RISC-V分页硬件（即`walk`函数模仿MMU硬件功能）。`walk`一次从3级页表中获取9个比特位。它使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE (**kernel/vm.c**:78)。如果PTE无效，则所需的页面还没有分配；如果设置了`alloc`参数，`walk`就会分配一个新的页表页面，并将其物理地址放在PTE中。它返回树中最低一级的PTE地址(**kernel/vm.c**:88)。



## Lecture5

#### 一些定义：

+ **硬件浮点单元**：硬件浮点单元（FPU）是一种**专门用于进行浮点数运算**的硬件设备。它可以**加速浮点运算**，提高计算机的性能。当 CPU 需要进行浮点运算时，可以通过三种不同的浮点运算器来执行运算：软件仿真模拟的浮点运算器，即浮点运算函数库；硬件附加的浮点运算器，即 CPU 外接的 FPU；硬件集成的浮点运算器。在没有硬件浮点运算器的情况下，也可以进行浮点运算，但是计算速度会慢很多。在大多数现代计算机的架构中，浮点运算和整数运算是分开的。

+ **软浮点约定**用于缺少硬件浮点单元的 RV32 和 RV64 实现中。它避免使用所有的 F、D、Q 标准扩展中的指令，以及 f 寄存器。整型参数如同 RVG 那样被传递和返回，并且栈的规则也相同。浮点参数通过整数寄存器传递和返回，使用相同大小整数参数相同的规则。

> F、D、Q 标准扩展是 RISC-V 指令集中的浮点标准扩展指令集。F 表示单精度浮点标准扩展指令集，D 表示双精度浮点标准扩展指令集，Q 表示四精度浮点标准扩展指令集

+ `RV32I` 和`RV64I` 是 RISC-V 指令集中的基础整数指令集。RV32I 是 32 位的基础指令集，而 RV64I 是 64 位的基础指令扩展。RISC-V 的体系结构是模块化的，可以在这个基础指令集上进行扩展，例如 RV32M 是乘法指令扩展，RV32F 是单精度浮点扩展，RV32D 是双精度浮点扩展等。RV32IMFD 就代表了把对应的模块扩展到基础的 RV32I 中。RV64I 是 RV32I 的超集，包括 RV32I 的所有 40 条指令，另外增加了 12 条 RV32I 中没有的指令，还有三条移位指令 (slli, srli, srai) 也进行小小的改动

+ `RV32G` 和 `RV64G` 是 RISC-V 指令集中的通用指令集。它们是基础 ISA（RV32I 或 RV64I）加上选定的标准扩展（IMAFD、Zicsr、Zifencei）的组合，被定义为“通用” ISA。我们相信 RV32G 和 RV64G 可以为各种通用计算提供简单而完整的指令集

![](/assets/images/datatypes.png)

**上面的表格，展示了riscv 在c 程序中的支持数据类型**，**long** 和 **指针** 数据类型，都是与一个整形寄存器的长度相同，即：RV32 中，两者都是32 bits长；在RV64中，都是64 bits长；

+ `char`和`short`是`zero-extended`，而`signed char`是`sign-extended`

#### RVG调用约定

+ 如果一个参数的大小**小于**一个指针字，那么它将被传递在参数寄存器的**最低有效位**中。相应地，如果这些小于指针字大小的参数通过栈传递，那么它们将出现在指针字的低地址中，因为 RISC-V 的内存系统是**小端序**的。

+ 当参数**两倍于**指针字大小，这些参数通过栈传递时，它们是自然对齐的。当它们通过整数寄存器传递时，它们位于一个对齐的**偶数-奇数寄存器对**中，其中偶数寄存器保存最低有效位。例如，在 RV32 中，函数 `void foo(int, long long)` 的第一个参数通过 `a0` 传递，第二个参数通过 `a2` 和 `a3` 传递。`a1` 中没有传递任何内容。

  举个例子，假设我们有一个函数原型如下：

  ```c
  void foo(int a, long long b);
  ```

  当我们调用这个函数时，第一个整数参数 `a` 将通过整数寄存器 `a0` 传递，第二个长整型参数 `b` 将通过整数寄存器 `a2` 和 `a3` 传递。注意，整数寄存器 `a1` 中没有传递任何内容。

+ 当一个参数的大小**大于两倍指针字**大小时，它将通过引用传递。这意味着，函数调用时不会直接传递参数的值，而是传递一个指向参数值的指针。

+ 如果将函数的参数看作是 C 结构体的字段，那么那些**不能通过寄存器传递的参数将通过栈传递**。栈指针 `sp` 指向第一个不能通过寄存器传递的参数。这意味着，当函数调用时，那些不能通过寄存器传递的参数将被压入栈中，然后通过栈指针访问。这样做的目的是为了确保所有参数都能够被正确地传递给函数。

![](/assets/images/reg.png)

上图为寄存器调用约定

#### 软浮点调用规定

+ 软浮点避免了浮点寄存器的使用

+ 整数参数的传递和返回方式与RVG约定相同，堆栈规则也是相同的。 浮点参数以整数寄存器的形式传递和返回，使用相同大小的整数参数规则。 例如，在RV32中，double函数 `Foo (int, double, long double)`在a0中传递它的第一个参数，在a2中传递它的第二个参数 a3和它通过a4引用的第三个参数; 其结果以a0和a1的形式返回。 在RV64, 参数以a0、a1和a2-a3的形式传递，结果以a0的形式返回。
