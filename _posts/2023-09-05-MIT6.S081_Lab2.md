---
title: MIT6.S081
layout: post
post-image: "https://image.baidu.com/search/down?tn=download&word=download&ie=utf8&fr=detail&url=https%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F0c9afc30856256436a2738bd1d05e68daa5bd3d2.jpg&thumburl=https%3A%2F%2Fimg0.baidu.com%2Fit%2Fu%3D2805645800%2C3904524944%26fm%3D253%26fmt%3Dauto%26app%3D120%26f%3DJPEG%3Fw%3D800%26h%3D500"
tags: OS
description: 这里是本人的第一篇博客，主要记录一下本人在课程MIT6.S081记录的部分笔记
---

## 前言
> 由于写此笔记的时候前三课并不在此记录(~~我懒得再写一遍~~)，故笔记从第四课开始

## Lecture 4
在上`lecture 4`前，我先阅读了`book-riscv-rev1`的第三章，有关`page table`

首先，**为什么需要页表**？

+ 页表的存在是为了实现强隔离性，防止一个程序影响另外的程序，或者影响操作系统，地址空间的概念使得程序之间能够彼此相互独立，如cat程序向地址1000写入数据，就不会影响到shell程序地址1000的位置。

**`SATP`寄存器：CPU中用于存放页表的物理地址的寄存器**，如果从一个程序切换到另一个程序，SATP中的地址也应相应的转换为另一个程序页表的物理地址（由内核完成写SATP寄存器的操作），对于多级页表，SATP寄存器会指向最高一级的`page directory`的物理内存地址



#### MMU:

+ `MMU`（`Memory Management Unit`，内存管理单元）是一种计算机硬件单元，它检查内存总线上的所有内存引用，将这些请求（称为虚拟内存地址）转换为主内存中的物理地址
+ MMU通过查找SATP寄存器，找到页表的位置，从而确定虚拟地址和物理地址的映射关系。

多级页表:

+ 一个多级页表，高层的页目录存放低层页目录的物理地址（44bit），然后用虚拟地址的某几位来索引低级页目录。
+ 值得注意的是。这里存放物理地址是44bit，而**剩余的低12bit全为0**，这样才组成了一个完整的物理地址，即下一级页目录的物理地址

优点：

+ **更加节省空间**，例如，如果应用程序仅使用从地址 0 开始的几个页，则顶层页目录的 1 到 511 项无效，并且内核不必为 511 中间页目录分配这些页。 此外，内核也不必为那些 511 个中间页目录的底层页目录分配页面。因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。

缺点：

+ 因为 CPU 在执行转换时会在硬件中遍历三级结构，所以**缺点**是 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将最近查找过的页表条目**缓存**在 `Translation Look-aside Buffer` (TLB) 中，即TLB会存放**最近的虚拟地址到物理地址的映射关系**。在切换`page table`时，TLB需要被清空，在RISC-V中，清空TLB的指令是`sfence_vma`



![Test Image2](/assets/images/page_table.png)

+ 每个PTE对应于一个`page`，用虚拟地址中index来查找，index查找到的地址是该页的**起始物理地址**，对应于4096个字节，而虚拟地址的offset则是查找对应于该page的哪部分字节，通常来说，一个page共有4096bytes，为 $2^{12}$ ，故需要12位的`offset`来索引位于那个字节
+ 如上图所示，在RISC-V中，虚拟地址的高 25位并未使用，只用了低39位，也就是说，虚拟地址的内存数量只有 $2^{39}$ 个，即512GB
+ RISC-V中，物理内存是56bit，也就是
+ 在RISC-V中，物理内存地址是56位，这意味着物理地址空间最大为2的56次方字节。然而，大多数主板还不支持这么大的物理内存，但原则上，如果能造出这样的主板，那么最多可以支持 $2^{56}$ 字节的物理内存。


![Test Image2](/assets/images/PTE.png)

如上图所示，每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。该图显示了它是如何工作的。标志和所有其他与页面硬件相关的结构在（**kernel/riscv.h**）中定义。



![Test Image](/assets/images/kernal_space.png)

+ 在进程地址空间中的`trampoline`和用户地址空间中的`trampoline`实际上是同一个东西。它们都指向内存中的同一个位置，用于在内核态和用户态之间进行切换。

+ 实际的物理地址空间中，低于0x80000000为不同的I/O设备，高于0x80000000会走向DRAM
+ `kernal text`存放代码，被标志为R-X，代码可读，可执行，但不可写，`kernal data`存放数据，可读写，但不可执行

#### 代码部分：

大多数用于操作地址空间和页表的xv6代码都写在 **vm.c** ([kernel/vm.c:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/vm.c#L1)) 中。最核心的函数是`walk`和`mappages`。

+ `mappages`函数的主要作用是在页表中创建新的虚拟地址到物理地址的映射。这意味着它将一个虚拟地址关联到一个物理地址，使得当程序试图访问这个虚拟地址时，硬件会自动将其转换为对应的物理地址。举个例子，假设我们有一个物理内存页，其物理地址是0x1000，我们想让一个进程能够通过虚拟地址0x2000来访问这个内存页。我们就可以使用`mappages`函数来创建这个映射。函数调用可能类似于`mappages(pagetable, 0x2000, PGSIZE, 0x1000, PTE_W | PTE_X | PTE_R)`。这样，当进程试图访问虚拟地址0x2000时，硬件会自动将其转换为物理地址0x1000，从而访问到正确的内存页。

+ 在查找PTE中的虚拟地址时，`walk`(**kernel/vm.c**:72)模仿RISC-V分页硬件（即`walk`函数模仿MMU硬件功能）。`walk`一次从3级页表中获取9个比特位。它使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE (**kernel/vm.c**:78)。如果PTE无效，则所需的页面还没有分配；如果设置了`alloc`参数，`walk`就会分配一个新的页表页面，并将其物理地址放在PTE中。它返回树中最低一级的PTE地址(**kernel/vm.c**:88)。



## Lecture 5

#### 一些定义：

+ **硬件浮点单元**：硬件浮点单元（FPU）是一种**专门用于进行浮点数运算**的硬件设备。它可以**加速浮点运算**，提高计算机的性能。当 CPU 需要进行浮点运算时，可以通过三种不同的浮点运算器来执行运算：软件仿真模拟的浮点运算器，即浮点运算函数库；硬件附加的浮点运算器，即 CPU 外接的 FPU；硬件集成的浮点运算器。在没有硬件浮点运算器的情况下，也可以进行浮点运算，但是计算速度会慢很多。在大多数现代计算机的架构中，浮点运算和整数运算是分开的。

+ **软浮点约定**用于缺少硬件浮点单元的 RV32 和 RV64 实现中。它避免使用所有的 F、D、Q 标准扩展中的指令，以及 f 寄存器。整型参数如同 RVG 那样被传递和返回，并且栈的规则也相同。浮点参数通过整数寄存器传递和返回，使用相同大小整数参数相同的规则。

> F、D、Q 标准扩展是 RISC-V 指令集中的浮点标准扩展指令集。F 表示单精度浮点标准扩展指令集，D 表示双精度浮点标准扩展指令集，Q 表示四精度浮点标准扩展指令集

+ `RV32I` 和`RV64I` 是 RISC-V 指令集中的基础整数指令集。RV32I 是 32 位的基础指令集，而 RV64I 是 64 位的基础指令扩展。RISC-V 的体系结构是模块化的，可以在这个基础指令集上进行扩展，例如 RV32M 是乘法指令扩展，RV32F 是单精度浮点扩展，RV32D 是双精度浮点扩展等。RV32IMFD 就代表了把对应的模块扩展到基础的 RV32I 中。RV64I 是 RV32I 的超集，包括 RV32I 的所有 40 条指令，另外增加了 12 条 RV32I 中没有的指令，还有三条移位指令 (slli, srli, srai) 也进行小小的改动

+ `RV32G` 和 `RV64G` 是 RISC-V 指令集中的通用指令集。它们是基础 ISA（RV32I 或 RV64I）加上选定的标准扩展（IMAFD、Zicsr、Zifencei）的组合，被定义为“通用” ISA。我们相信 RV32G 和 RV64G 可以为各种通用计算提供简单而完整的指令集

![](/assets/images/datatypes.png)

**上面的表格，展示了riscv 在c 程序中的支持数据类型**，**long** 和 **指针** 数据类型，都是与一个整形寄存器的长度相同，即：RV32 中，两者都是32 bits长；在RV64中，都是64 bits长；

+ `char`和`short`是`zero-extended`，而`signed char`是`sign-extended`

#### RVG调用约定

+ 如果一个参数的大小**小于**一个指针字，那么它将被传递在参数寄存器的**最低有效位**中。相应地，如果这些小于指针字大小的参数通过栈传递，那么它们将出现在指针字的低地址中，因为 RISC-V 的内存系统是**小端序**的。

+ 当参数**两倍于**指针字大小，这些参数通过栈传递时，它们是自然对齐的。当它们通过整数寄存器传递时，它们位于一个对齐的**偶数-奇数寄存器对**中，其中偶数寄存器保存最低有效位。例如，在 RV32 中，函数 `void foo(int, long long)` 的第一个参数通过 `a0` 传递，第二个参数通过 `a2` 和 `a3` 传递。`a1` 中没有传递任何内容。

  举个例子，假设我们有一个函数原型如下：

  ```c
  void foo(int a, long long b);
  ```

  当我们调用这个函数时，第一个整数参数 `a` 将通过整数寄存器 `a0` 传递，第二个长整型参数 `b` 将通过整数寄存器 `a2` 和 `a3` 传递。注意，整数寄存器 `a1` 中没有传递任何内容。

+ 当一个参数的大小**大于两倍指针字**大小时，它将通过引用传递。这意味着，函数调用时不会直接传递参数的值，而是传递一个指向参数值的指针。

+ 如果将函数的参数看作是 C 结构体的字段，那么那些**不能通过寄存器传递的参数将通过栈传递**。栈指针 `sp` 指向第一个不能通过寄存器传递的参数。这意味着，当函数调用时，那些不能通过寄存器传递的参数将被压入栈中，然后通过栈指针访问。这样做的目的是为了确保所有参数都能够被正确地传递给函数。

![](/assets/images/reg.png)

上图为寄存器调用约定，通常情况我们使用**ABI**的名字，包括写汇编代码的时候也是用ABI名字

+ Caller Saved寄存器在函数调用的时候不会保存
+ Callee Saved寄存器在函数调用的时候会保存

> 意思是一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器，例如return address，因此函数a调用函数b的时候，要用堆栈先保留自身的返回地址，因为，ra会被调用的函数b的返回地址覆写，而那个被调用的函数b的返回地址就是调用他的函数a，即为该函数自身，如果不预先存好ra，会陷入死循环

![](/assets/images/stack.png)

上图为栈结构，每一个区域都是一个`Stack Frame`，每执行一次函数调用就会产生一个`Stack Frame`，函数通过移动`Stack Pointer`来完成`Stack Frame`的空间分配。

+ 对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的`Stack Frame`的时候，总是对当前的`Stack Pointer`做减法。
+ 不同的寄存器，所以`Stack Frame`的大小是不一样的。但是有关`Stack Frame`有两件事情是确定的：
  - `Return address`总是会出现在`Stack Frame`的第一位
  - 指向前一个`Stack Frame`的指针也会出现在栈中的固定位置
+ 有关`Stack Frame`中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前`Stack Frame`的位置。第二个是FP（Frame Pointer），它指向当前`Stack Frame`的顶部。因为`Return address`和指向前一个`Stack Frame`的的指针都在当前`Stack Frame`的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。
+  RISC-V 调用约定中的栈行为。在标准的 RISC-V 调用约定中，栈是向下增长的，也就是说，新添加到栈中的元素会被放在内存地址更低的位置。此外，栈指针始终保持 16 字节对齐，这意味着栈指针的值总是 16 的倍数。

> **栈帧（stack frame）**是计算机程序中用于保存函数调用信息的一种数据结构。当一个函数被调用时，一个新的栈帧会被创建并压入栈中。这个栈帧包含了函数的参数、局部变量、返回地址以及其他与函数调用相关的信息。当函数返回时，对应的栈帧会被弹出栈并销毁，以便为下一次函数调用腾出空间。栈帧是实现函数调用和递归的重要数据结构。它们通常由编译器自动生成，并在运行时由程序自动管理。

#### 软浮点调用规定

+ 软浮点避免了浮点寄存器的使用

+ 整数参数的传递和返回方式与RVG约定相同，堆栈规则也是相同的。 浮点参数以整数寄存器的形式传递和返回，使用相同大小的整数参数规则。 例如，在RV32中，double函数 `Foo (int, double, long double)`在a0中传递它的第一个参数，在a2中传递它的第二个参数 a3和它通过a4引用的第三个参数; 其结果以a0和a1的形式返回。 在RV64, 参数以a0、a1和a2-a3的形式传递，结果以a0的形式返回。



### Lecture 6

有三种事件会导致CPU搁置普通命令的执行，强制将控制权转交给处理该事件的特殊代码。

- **系统调用(system call)**：执行ecall指令，向内核请求并操作特定硬件资源。
- **异常(exception)**：由尝试做非法事件的指令触发，例如除零操作。
- **设备中断(device interrupt)**：当设备发出信号时提示内核需要注意，例如当磁盘完成读写请求时。 

**xv6使用`trap`(陷阱)作为这三种情况的术语**

通常的顺序是：

1. 陷阱强制将控制权转移到内核
2. 内核保存寄存器和其他状态，以便可以恢复执行
3. 内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）
4. 内核恢复保存的状态并从陷阱中返回
5. 原始代码从它停止的地方恢复。



每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。以下是最重要的一些寄存器概述：

- `stvec`：内核在这里写入其**陷阱处理程序的地址**；RISC-V跳转到这里处理陷阱。
- `sepc`：当发生陷阱时，RISC-V会在这里**保存程序计数器`pc`**（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向。
- `scause`： RISC-V在这里放置一个描**述陷阱原因**的数字。
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。
- `sstatus`：其中的**SIE**位控制设备中断是否启用。如果内核清空**SIE**，RISC-V将推迟设备中断，直到内核重新设置**SIE**，这样可以确保在处理某些重要任务时，不会被设备中断打断。**SPP**位指示陷阱是来自用户模式还是管理模式，并控制`sret`返回的模式。

上述寄存器都用于在管理模式下处理陷阱，在用户模式下不能读取或写入。在机器模式下处理陷阱有一组等效的控制寄存器，xv6仅在计时器中断的特殊情况下使用它们。

多核芯片上的每个CPU都有自己的这些寄存器集，并且在任何给定时间都可能有多个CPU在处理陷阱。

当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：

1. 如果陷阱是设备中断，并且状态**SIE**位被清空，则不执行以下任何操作。
2. 清除**SIE**以禁用中断。
3. 将`pc`复制到`sepc`。
4. 将当前模式（用户或管理）保存在状态的**SPP**位中。
5. 设置`scause`以反映产生陷阱的原因。
6. 将模式设置为管理模式。
7. 将`stvec`复制到`pc`。
8. 在新的`pc`上开始执行。

#### uservec函数：

![](/assets/images/trapframe.png)

在进入到user space之前，内核会将`trapframe page`的地址保存在`SSCRATCH`寄存器中，也就是`0x3fffffe000`这个地址。
