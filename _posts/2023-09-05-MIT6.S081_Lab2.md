---
title: MIT6.S081
layout: post
post-image: "https://www.veer.com/photo/169425945.html"
tags: OS
description: 这里是本人的第一篇博客，主要记录一下本人在课程MIT6.S081记录的部分笔记
---

## 前言
> 由于写此笔记的时候前三课并不在此记录(~~我懒得再写一遍~~)，故笔记从第四课开始

## Lecture 4
在上`lecture 4`前，我先阅读了`book-riscv-rev1`的第三章，有关`page table`

首先，**为什么需要页表**？

+ 页表的存在是为了实现强隔离性，防止一个程序影响另外的程序，或者影响操作系统，地址空间的概念使得程序之间能够彼此相互独立，如cat程序向地址1000写入数据，就不会影响到shell程序地址1000的位置。

**`SATP`寄存器：CPU中用于存放页表的物理地址的寄存器**，如果从一个程序切换到另一个程序，SATP中的地址也应相应的转换为另一个程序页表的物理地址（由内核完成写SATP寄存器的操作），对于多级页表，SATP寄存器会指向最高一级的`page directory`的物理内存地址



#### MMU:

+ MMU（Memory Management Unit，内存管理单元）是一种计算机硬件单元，它检查内存总线上的所有内存引用，将这些请求（称为虚拟内存地址）转换为主内存中的物理地址
+ MMU通过查找SATP寄存器，找到页表的位置，从而确定虚拟地址和物理地址的映射关系。

多级页表:

+ 一个多级页表，高层的页目录存放低层页目录的物理地址（44bit），然后用虚拟地址的某几位来索引低级页目录。
+ 值得注意的是。这里存放物理地址是44bit，而**剩余的低12bit全为0**，这样才组成了一个完整的物理地址，即下一级页目录的物理地址

优点：

+ **更加节省空间**，例如，如果应用程序仅使用从地址 0 开始的几个页，则顶层页目录的 1 到 511 项无效，并且内核不必为 511 中间页目录分配这些页。 此外，内核也不必为那些 511 个中间页目录的底层页目录分配页面。因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。

缺点：

+ 因为 CPU 在执行转换时会在硬件中遍历三级结构，所以**缺点**是 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将最近查找过的页表条目**缓存**在 `Translation Look-aside Buffer` (TLB) 中，即TLB会存放**最近的虚拟地址到物理地址的映射关系**。在切换`page table`时，TLB需要被清空，在RISC-V中，清空TLB的指令是`sfence_vma`



![Test Image2](/assets/images/page_table.png)

+ 每个PTE对应于一个`page`，用虚拟地址中index来查找，index查找到的地址是该页的**起始物理地址**，对应于4096个字节，而虚拟地址的offset则是查找对应于该page的哪部分字节，通常来说，一个page共有4096bytes，为 $2^{12}$ ，故需要12位的`offset`来索引位于那个字节
+ 如上图所示，在RISC-V中，虚拟地址的高 25位并未使用，只用了低39位，也就是说，虚拟地址的内存数量只有 $2^{39}$ 个，即512GB
+ RISC-V中，物理内存是56bit，也就是
+ 在RISC-V中，物理内存地址是56位，这意味着物理地址空间最大为2的56次方字节。然而，大多数主板还不支持这么大的物理内存，但原则上，如果能造出这样的主板，那么最多可以支持 $2^{56}$ 字节的物理内存。


![Test Image2](/assets/images/PTE.png)

如上图所示，每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。该图显示了它是如何工作的。标志和所有其他与页面硬件相关的结构在（**kernel/riscv.h**）中定义。



![Test Image](/assets/images/kernal_space.png)

+ 在进程地址空间中的`trampoline`和用户地址空间中的`trampoline`实际上是同一个东西。它们都指向内存中的同一个位置，用于在内核态和用户态之间进行切换。

+ 实际的物理地址空间中，低于0x80000000为不同的I/O设备，高于0x80000000会走向DRAM
+ kernal text存放代码，被标志为R-X，代码可读，可执行，但不可写，kernal data存放数据，可读写，但不可执行

## 代码部分：

大多数用于操作地址空间和页表的xv6代码都写在 **vm.c** ([kernel/vm.c:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/vm.c#L1)) 中。最核心的函数是`walk`和`mappages`。

+ `mappages`函数的主要作用是在页表中创建新的虚拟地址到物理地址的映射。这意味着它将一个虚拟地址关联到一个物理地址，使得当程序试图访问这个虚拟地址时，硬件会自动将其转换为对应的物理地址。举个例子，假设我们有一个物理内存页，其物理地址是0x1000，我们想让一个进程能够通过虚拟地址0x2000来访问这个内存页。我们就可以使用`mappages`函数来创建这个映射。函数调用可能类似于`mappages(pagetable, 0x2000, PGSIZE, 0x1000, PTE_W | PTE_X | PTE_R)`。这样，当进程试图访问虚拟地址0x2000时，硬件会自动将其转换为物理地址0x1000，从而访问到正确的内存页。

+ 在查找PTE中的虚拟地址（参见图3.2）时，`walk`(**kernel/vm.c**:72)模仿RISC-V分页硬件（即`walk`函数模仿MMU硬件功能）。`walk`一次从3级页表中获取9个比特位。它使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE (**kernel/vm.c**:78)。如果PTE无效，则所需的页面还没有分配；如果设置了`alloc`参数，`walk`就会分配一个新的页表页面，并将其物理地址放在PTE中。它返回树中最低一级的PTE地址(**kernel/vm.c**:88)。
