---
title: MIT6.S081
layout: post
description: 这里是本人的第一篇博客，主要记录一下本人在课程MIT6.S081记录的部分笔记
---

## 前言
> 由于写此笔记的时候前三课并不在此记录(~~我懒得再写一遍~~)，故笔记从第四课开始

## Lecture 4
在上`lecture 4`前，我先阅读了`book-riscv-rev1`的第三章，有关`page table`

![Test Image2](/assets/images/page_table.png)

多级页表优点:

+ **更加节省空间**，例如，如果应用程序仅使用从地址 0 开始的几个页，则顶层页目录的 1 到 511 项无效，并且内核不必为 511 中间页目录分配这些页。 此外，内核也不必为那些 511 个中间页目录的底层页目录分配页面。因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。

缺点：

+ 因为 CPU 在执行转换时会在硬件中遍历三级结构，所以**缺点**是 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer (TLB) 中。

![Test Image2](/assets/images/PTE.png)

如上图所示，每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。该图显示了它是如何工作的。标志和所有其他与页面硬件相关的结构在（**kernel/riscv.h**）中定义。

> 在进程地址空间中的`trampoline`和用户地址空间中的`trampoline`实际上是同一个东西。它们都指向内存中的同一个位置，用于在内核态和用户态之间进行切换。

## 代码部分：

大多数用于操作地址空间和页表的xv6代码都写在 **vm.c** ([kernel/vm.c:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/vm.c#L1)) 中。最核心的函数是`walk`和`mappages`。

+ `mappages`函数的主要作用是在页表中创建新的虚拟地址到物理地址的映射。这意味着它将一个虚拟地址关联到一个物理地址，使得当程序试图访问这个虚拟地址时，硬件会自动将其转换为对应的物理地址。举个例子，假设我们有一个物理内存页，其物理地址是0x1000，我们想让一个进程能够通过虚拟地址0x2000来访问这个内存页。我们就可以使用`mappages`函数来创建这个映射。函数调用可能类似于`mappages(pagetable, 0x2000, PGSIZE, 0x1000, PTE_W | PTE_X | PTE_R)`。这样，当进程试图访问虚拟地址0x2000时，硬件会自动将其转换为物理地址0x1000，从而访问到正确的内存页。

+ 在查找PTE中的虚拟地址（参见图3.2）时，`walk`(**kernel/vm.c**:72)模仿RISC-V分页硬件。`walk`一次从3级页表中获取9个比特位。它使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE (**kernel/vm.c**:78)。如果PTE无效，则所需的页面还没有分配；如果设置了`alloc`参数，`walk`就会分配一个新的页表页面，并将其物理地址放在PTE中。它返回树中最低一级的PTE地址(**kernel/vm.c**:88)。